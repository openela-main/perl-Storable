From 0452589669aed9ad06940de7c1620b340608868a Mon Sep 17 00:00:00 2001
From: Jitka Plesnikova <jplesnik@redhat.com>
Date: Mon, 1 Jun 2020 12:58:11 +0200
Subject: [PATCH] Upgrade to 3.21

---
 ChangeLog                      | 33 ++++++++++++++++++-
 MANIFEST                       |  3 +-
 Makefile.PL                    | 59 +++++++++++++---------------------
 __Storable__.pm => Storable.pm | 23 +++++++------
 Storable.pm.PL                 | 35 --------------------
 Storable.xs                    | 20 ++++++++----
 stacksize                      |  2 +-
 t/attach_errors.t              |  2 +-
 t/huge.t                       |  4 +--
 t/recurse.t                    |  4 +--
 t/regexp.t                     |  8 ++---
 11 files changed, 93 insertions(+), 100 deletions(-)
 rename __Storable__.pm => Storable.pm (99%)
 delete mode 100644 Storable.pm.PL

diff --git a/ChangeLog b/ChangeLog
index 0488199..bf35381 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,34 @@
+2010-01-27 10:27:00 TonyC
+    version 3.20
+        * fix a format string and arguments for some debugging text
+        * linkify references to alternatives to Storable
+
+2020-01-27 11:01:00 TonyC
+    version 3.19
+        * add casts to match some I32 parameters to "%d" formats (#17339)
+        * fix dependencies in Makefile.PL -> META (#17422)
+        * make use of note() optional, this requires a newer version of
+          Test::More and there's a circular dependency between later
+          versions of Test::More and Storable  (#17422)
+
+2019-11-19 07:59:39 TonyC
+    version 3.18
+        * update bug tracker to point at github (#17298)
+        * disallow vstring magic strings over 2GB-1 (#17306)
+        * mark some ASCII dependent tests as ASCII platform only
+
+2019-08-08 11:48:00 TonyC
+    version 3.17
+        * correct a data type to ensure the check for too large results from
+	  STORABLE_freeze() are detected correctly (detected by Coverity)
+	* removed remains of stack size detection from the build process.
+	* moved CAN_FLOCK detection into XS to simplify the build process.
+
+2019-06-11 10:43:00 TonyC
+    version 3.16
+        * (perl #134179) fix self-referencing structures that include regexps
+        * bless regexps to preserve bless qr//, "Foo"
+
 2019-04-23 16:00:00 xsawyerx
     version 3.15
     * Fix leaking.
@@ -341,7 +372,7 @@ Sat Mar 13 20:11:03 GMT 2004   Nicholas Clark <nick@ccl4.org>
     Version 2.11
 
         1. Storing restricted hashes in canonical order would SEGV. Fixed.
-        2. It was impossible to retrieve references to PL_sv_no and and
+        2. It was impossible to retrieve references to PL_sv_no and
            PL_sv_undef from STORABLE_thaw hooks.
         3. restrict.t was failing on 5.8.0, due to 5.8.0's unique
            implementation of restricted hashes using PL_sv_undef
diff --git a/MANIFEST b/MANIFEST
index d30b94e..5e382d9 100644
--- a/MANIFEST
+++ b/MANIFEST
@@ -1,4 +1,3 @@
-__Storable__.pm
 ChangeLog
 hints/gnukfreebsd.pl
 hints/gnuknetbsd.pl
@@ -11,7 +10,7 @@ META.yml			Module meta-data (added by MakeMaker)
 ppport.h
 README
 stacksize
-Storable.pm.PL
+Storable.pm
 Storable.xs
 t/attach.t
 t/attach_errors.t
diff --git a/Makefile.PL b/Makefile.PL
index 4a39125..e03e141 100644
--- a/Makefile.PL
+++ b/Makefile.PL
@@ -10,43 +10,48 @@ use strict;
 use warnings;
 use ExtUtils::MakeMaker 6.31;
 use Config;
-use File::Copy qw(move copy);
-use File::Spec;
-
-my $pm = { 'Storable.pm' => '$(INST_ARCHLIB)/Storable.pm' };
 
 WriteMakefile(
     NAME                => 'Storable',
     AUTHOR              => 'Perl 5 Porters',
     LICENSE             => 'perl',
     DISTNAME            => "Storable",
-# We now ship this in t/
-#    PREREQ_PM           => { 'Test::More' => '0.41' },
-    PL_FILES        => { }, # prevent default behaviour
-    PM              => $pm,
-    PREREQ_PM           => { XSLoader => 0 },
+    PREREQ_PM           =>
+      {
+          XSLoader => 0,
+      },
+    ( $ExtUtils::MakeMaker::VERSION >= 6.64 ?
+        (
+            CONFIGURE_REQUIRES => {
+                'ExtUtils::MakeMaker' => '6.31',
+            },
+            BUILD_REQUIRES => {
+                'ExtUtils::MakeMaker' => '6.31',
+            },
+            TEST_REQUIRES => {
+                'Test::More' => '0.41',
+            },
+           )
+        : () ),
     INSTALLDIRS => ($] >= 5.007 && $] < 5.012) ? 'perl' : 'site',
-    VERSION_FROM    => '__Storable__.pm',
-    ABSTRACT_FROM   => '__Storable__.pm',
+    VERSION_FROM    => 'Storable.pm',
+    ABSTRACT_FROM   => 'Storable.pm',
     ($ExtUtils::MakeMaker::VERSION > 6.45 ?
      (META_MERGE        => { resources =>
-                               { bugtracker => 'http://rt.perl.org/perlbug/' },
+                               { bugtracker => 'https://github.com/Perl/perl5/issues' },
                             provides    => {
                                 'Storable'  => {
-                                    file        => '__Storable__.pm',
-                                    version     => MM->parse_version('__Storable__.pm'),
+                                    file        => 'Storable.pm',
+                                    version     => MM->parse_version('Storable.pm'),
                                 },
                             },
 
                            },
     ) : ()),
     dist                => { SUFFIX => 'gz', COMPRESS => 'gzip -f' },
-    clean               => { FILES => 'Storable-* Storable.pm lib' },
+    clean               => { FILES => 'Storable-*' },
 );
 
-# Unlink the .pm file included with the distribution
-1 while unlink "Storable.pm";
-
 my $ivtype = $Config{ivtype};
 
 # I don't know if the VMS folks ever supported long long on 5.6.x
@@ -67,16 +72,8 @@ in the Storable documentation for instructions on how to read your data.
 EOM
 }
 
-# compute the maximum stacksize, before and after linking
 package MY;
 
-# FORCE finish of INST_DYNAMIC, avoid loading the old Storable (failed XS_VERSION check)
-sub xlinkext {
-    my $s = shift->SUPER::linkext(@_);
-    $s =~ s|( :: .*)| $1 FORCE stacksize|;
-    $s
-}
-
 sub depend {
     "
 
@@ -87,13 +84,3 @@ release : dist
 	git push --tags
 "
 }
-
-sub postamble {
-'
-all :: Storable.pm
-	$(NOECHO) $(NOOP)
-
-Storable.pm :: Storable.pm.PL __Storable__.pm
-	$(PERLRUN) Storable.pm.PL
-'
-}
diff --git a/__Storable__.pm b/Storable.pm
similarity index 99%
rename from __Storable__.pm
rename to Storable.pm
index 9237371..1a750f1 100644
--- a/__Storable__.pm
+++ b/Storable.pm
@@ -8,7 +8,7 @@
 #  in the README file that comes with the distribution.
 #
 
-require XSLoader;
+BEGIN { require XSLoader }
 require Exporter;
 package Storable;
 
@@ -27,7 +27,9 @@ our @EXPORT_OK = qw(
 
 our ($canonical, $forgive_me);
 
-our $VERSION = '3.15';
+BEGIN {
+  our $VERSION = '3.21';
+}
 
 our $recursion_limit;
 our $recursion_limit_hash;
@@ -104,14 +106,12 @@ $Storable::flags = FLAGS_COMPAT;
 $Storable::downgrade_restricted = 1;
 $Storable::accept_future_minor = 1;
 
-XSLoader::load('Storable');
+BEGIN { XSLoader::load('Storable') };
 
 #
 # Determine whether locking is possible, but only when needed.
 #
 
-sub CAN_FLOCK; # TEMPLATE - replaced by Storable.pm.PL
-
 sub show_file_magic {
     print <<EOM;
 #
@@ -266,7 +266,7 @@ sub _store {
     local *FILE;
     if ($use_locking) {
         open(FILE, ">>", $file) || logcroak "can't write into $file: $!";
-        unless (&CAN_FLOCK) {
+        unless (CAN_FLOCK) {
             logcarp
               "Storable::lock_store: fcntl/flock emulation broken on $^O";
             return undef;
@@ -410,7 +410,7 @@ sub _retrieve {
     my $self;
     my $da = $@;			# Could be from exception handler
     if ($use_locking) {
-        unless (&CAN_FLOCK) {
+        unless (CAN_FLOCK) {
             logcarp
               "Storable::lock_store: fcntl/flock emulation broken on $^O";
             return undef;
@@ -986,6 +986,9 @@ modifying C<$Storable::recursion_limit> and
 C<$Storable::recursion_limit_hash> respectively.  Either can be set to
 C<-1> to prevent any depth checks, though this isn't recommended.
 
+If you want to test what the limits are, the F<stacksize> tool is
+included in the C<Storable> distribution.
+
 =item *
 
 You can create endless loops if the things you serialize via freeze()
@@ -1224,9 +1227,9 @@ See CVE-2015-1592 and its metasploit module.
 If your application requires accepting data from untrusted sources,
 you are best off with a less powerful and more-likely safe
 serialization format and implementation. If your data is sufficiently
-simple, Cpanel::JSON::XS, Data::MessagePack or Serial are the best
-choices and offers maximum interoperability, but note that Serial is
-unsafe by default.
+simple, L<Cpanel::JSON::XS>, L<Data::MessagePack> or L<Sereal> are the best
+choices and offer maximum interoperability, but note that Sereal is
+L<unsafe by default|Sereal::Decoder/ROBUSTNESS>.
 
 =head1 WARNING
 
diff --git a/Storable.pm.PL b/Storable.pm.PL
deleted file mode 100644
index df979c0..0000000
--- a/Storable.pm.PL
+++ /dev/null
@@ -1,35 +0,0 @@
-use strict;
-use warnings;
-
-use Config;
-
-my $template;
-{	# keep all the code in an external template to keep it easy to update
-	local $/;
-	open my $FROM, '<', '__Storable__.pm' or die $!;
-	$template = <$FROM>;
-	close $FROM or die $!;
-}
-
-sub CAN_FLOCK {
-	return
-		$Config{'d_flock'} ||
-		$Config{'d_fcntl_can_lock'} ||
-		$Config{'d_lockf'}
-		? 1 : 0;
-}
-
-my $CAN_FLOCK = CAN_FLOCK();
-
-# populate the sub and preserve it if used outside
-$template =~ s{^sub CAN_FLOCK;.*$}{sub CAN_FLOCK { ${CAN_FLOCK} } # computed by Storable.pm.PL}m;
-# alternatively we could remove the sub
-#$template =~ s{^sub CAN_FLOCK;.*$}{}m;
-# replace local function calls to hardcoded value
-$template =~ s{&CAN_FLOCK}{${CAN_FLOCK}}g;
-
-{
-	open my $OUT, '>', 'Storable.pm' or die $!;
-	print {$OUT} $template or die $!;
-	close $OUT or die $!;
-}
diff --git a/Storable.xs b/Storable.xs
index e1f0b88..4c4c268 100644
--- a/Storable.xs
+++ b/Storable.xs
@@ -104,6 +104,12 @@
 #  define strEQc(s,c) memEQ(s, ("" c ""), sizeof(c))
 #endif
 
+#if defined(HAS_FLOCK) || defined(FCNTL_CAN_LOCK) && defined(HAS_LOCKF)
+#define CAN_FLOCK &PL_sv_yes
+#else
+#define CAN_FLOCK &PL_sv_no
+#endif
+
 #ifdef DEBUGME
 
 #ifndef DASSERT
@@ -726,8 +732,8 @@ static stcxt_t *Context_ptr = NULL;
         STRLEN nsz = (STRLEN) round_mgrow((x)+msiz);            \
         STRLEN offset = mptr - mbase;                           \
         ASSERT(!cxt->membuf_ro, ("mbase is not read-only"));    \
-        TRACEME(("** extending mbase from %ld to %ld bytes (wants %ld new)", \
-                 (long)msiz, nsz, (long)(x)));                  \
+        TRACEME(("** extending mbase from %lu to %lu bytes (wants %lu new)", \
+                 (unsigned long)msiz, (unsigned long)nsz, (unsigned long)(x)));  \
         Renew(mbase, nsz, char);                                \
         msiz = nsz;                                             \
         mptr = mbase + offset;                                  \
@@ -3085,7 +3091,7 @@ static int store_hash(pTHX_ stcxt_t *cxt, HV *hv)
             len = HEK_LEN(hek);
             if (len == HEf_SVKEY) {
                 /* This is somewhat sick, but the internal APIs are
-                 * such that XS code could put one of these in in
+                 * such that XS code could put one of these in
                  * a regular hash.
                  * Maybe we should be capable of storing one if
                  * found.
@@ -3437,7 +3443,7 @@ static int get_regexp(pTHX_ stcxt_t *cxt, SV* sv, SV **re, SV **flags) {
     count = call_sv((SV*)cv, G_ARRAY);
     SPAGAIN;
     if (count < 2)
-      CROAK(("re::regexp_pattern returned only %d results", count));
+      CROAK(("re::regexp_pattern returned only %d results", (int)count));
     *flags = POPs;
     SvREFCNT_inc(*flags);
     *re = POPs;
@@ -5952,7 +5958,7 @@ static SV *retrieve_lvstring(pTHX_ stcxt_t *cxt, const char *cname)
     }
 
     New(10003, s, len+1, char);
-    SAFEPVREAD(s, len, s);
+    SAFEPVREAD(s, (I32)len, s);
 
     sv = retrieve(aTHX_ cxt, cname);
     if (!sv) {
@@ -6858,7 +6864,7 @@ static SV *retrieve_regexp(pTHX_ stcxt_t *cxt, const char *cname) {
     SPAGAIN;
 
     if (count != 1)
-        CROAK(("Bad count %d calling _make_re", count));
+        CROAK(("Bad count %d calling _make_re", (int)count));
 
     re_ref = POPs;
 
@@ -7807,6 +7813,8 @@ BOOT:
     newCONSTSUB(stash, "BIN_MINOR", newSViv(STORABLE_BIN_MINOR));
     newCONSTSUB(stash, "BIN_WRITE_MINOR", newSViv(STORABLE_BIN_WRITE_MINOR));
 
+    newCONSTSUB(stash, "CAN_FLOCK", CAN_FLOCK);
+
     init_perinterp(aTHX);
     gv_fetchpv("Storable::drop_utf8",   GV_ADDMULTI, SVt_PV);
 #ifdef DEBUGME
diff --git a/stacksize b/stacksize
index f93eccc..2896684 100644
--- a/stacksize
+++ b/stacksize
@@ -161,7 +161,7 @@ my $max_depth_hash = $n;
 # instead so a user setting of either variable more closely matches
 # the limits the use sees.
 
-# be fairly aggressive in trimming this, smoke testing showed several
+# be fairly aggressive in trimming this, smoke testing showed
 # several apparently random failures here, eg. working in one
 # configuration, but not in a very similar configuration.
 $max_depth = int(0.6 * $max_depth);
diff --git a/t/attach_errors.t b/t/attach_errors.t
index 0ed7c8d..e2be39d 100644
--- a/t/attach_errors.t
+++ b/t/attach_errors.t
@@ -94,7 +94,7 @@ use Storable ();
 # Error 2
 #
 # If, for some reason, a STORABLE_attach object is accidentally stored
-# with references, this should be checked and and error should be throw.
+# with references, this should be checked and an error should be thrown.
 
 
 
diff --git a/t/huge.t b/t/huge.t
index d28e238..09b173e 100644
--- a/t/huge.t
+++ b/t/huge.t
@@ -63,7 +63,7 @@ if ($Config{ptrsize} > 4 and !$has_too_many) {
           [ 'huge array',
             sub { my @x; $x[$huge] = undef; \@x } ];
     } else {
-        diag "skip huge array, need PERL_TEST_MEMORY >= 8";
+        diag "skip huge array, need PERL_TEST_MEMORY >= 55";
     }
 }
 
@@ -78,7 +78,7 @@ if (!$has_too_many) {
           ['huge hash',
            sub { my %x = (0 .. $huge); \%x } ];
     } else {
-        diag "skip huge hash, need PERL_TEST_MEMORY >= 16";
+        diag "skip huge hash, need PERL_TEST_MEMORY >= 96";
     }
 }
 
diff --git a/t/recurse.t b/t/recurse.t
index b5967a0..6f82169 100644
--- a/t/recurse.t
+++ b/t/recurse.t
@@ -347,7 +347,7 @@ sub MAX_DEPTH_HASH () { Storable::stack_depth_hash() }
 eval {
     my $t;
     $t = [$t] for 1 .. MAX_DEPTH*2;
-    note 'trying catching recursive aref stack overflow';
+    eval { note('trying catching recursive aref stack overflow') };
     dclone $t;
 };
 like $@, qr/Max\. recursion depth with nested structures exceeded/,
@@ -362,7 +362,7 @@ else {
         my $t;
         # 35.000 will cause appveyor 64bit windows to fail earlier
         $t = {1=>$t} for 1 .. MAX_DEPTH * 2;
-        note 'trying catching recursive href stack overflow';
+        eval { note('trying catching recursive href stack overflow') };
         dclone $t;
     };
     like $@, qr/Max\. recursion depth with nested structures exceeded/,
diff --git a/t/regexp.t b/t/regexp.t
index e7c6c7e..6c6b1d5 100644
--- a/t/regexp.t
+++ b/t/regexp.t
@@ -123,7 +123,7 @@ __DATA__
 A-; qr(\x2E) ; ".", !"a" ; \x2E - hex meta
 -; qr/\./ ; "." , !"a" ; \. - backslash meta
 8- ; qr/\x{100}/ ; "\x{100}" ; simple unicode
-12- ; qr/fss/i ; "f\xDF\x{101}" ; case insensive unicode promoted
-22-; qr/fss/ui ; "f\xDF" ; case insensitive unicode SS /iu
-22-; qr/fss/aai ; !"f\xDF" ; case insensitive unicode SS /iaa
-22-; qr/f\w/a ; "fo", !"f\xff" ; simple /a flag
+A12- ; qr/fss/i ; "f\xDF\x{101}" ; case insensive unicode promoted
+A22-; qr/fss/ui ; "f\xDF" ; case insensitive unicode SS /iu
+A22-; qr/fss/aai ; !"f\xDF" ; case insensitive unicode SS /iaa
+A22-; qr/f\w/a ; "fo", !"f\xff" ; simple /a flag
-- 
2.25.4

